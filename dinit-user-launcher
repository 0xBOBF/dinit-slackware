#!/bin/bash
#
# Spawn a dinit user service for a user, and monitor when the session ends from (e)logind so we can 
# shutdown dinit cleanly.
# 

dinit_user_launcher () {
  # Create the runtime directory and set user's ownership:
  # We need to do this sine we will run before elogind, and
  # we want to link dinitctl here for runtime operation.
  runtimedir="/run/user/$uid"
  mkdir -p "$runtimedir" && chown -R ${name}:users $runtimedir

  # Spawn a dinit instance for the user, make the socket in home instead of
  # runtimedir, so elogind doesn't delete it automatically at session end.
  # Link the dinitctl socket to the runtimedir, so dinitctl defaults work
  # once XDG_RUNTIME_DIR is set:
  su -l -c "dinit -d /etc/dinit/user -p $home/.dinitctl &" $name
  su -l -c "ln -s $home/.dinitctl $runtimedir/dinitctl" $name

  # Monitor system dbus for logind's UserRemoved message. Keep the pipe in user's runtimedir.
  pipe="$runtimedir/logind.pipe"
  mkfifo $pipe && chown ${name}:users $pipe
  gdbus monitor --system --dest org.freedesktop.login1 --object-path=/org/freedesktop/login1 > $pipe &
  gdbus_pid="$!"
  trap "kill $gdbus_pid && rm -f $pipe" EXIT

  while read -r line
  do
    if [ "$(echo "$line" | grep -o 'UserRemoved (uint32 [0-9]*' | cut -d' ' -f 3)" = "$uid" ]; then
      break
    fi
  done < $pipe 

  # Anything executed after here is after logout:
  su -l -c "dinitctl shutdown" $name
}

# Get the user name from $1 or $PAM_USER if launched from PAM.
if [ -n "$PAM_USER" ]; then
  name=$PAM_USER
elif [ -n "$1" ]; then
  name=$1
else
  echo "Error: User name wasn't supplied."
  exit 1
fi

# Test if name is valid, then get the id and home dir:
uid="$(id -u $name 2> /dev/null)"
if [ -z "$uid" ]; then
  echo "'$name' is not valid."
  exit 1
fi
home="$(grep $name /etc/passwd | cut -d: -f6)"

# Run the launcher and background:
dinit_user_launcher &
